---
layout: post
title: 多项式的基本运算
category: mathematics
tags: [ 数学, 抽象代数, 多项式, 高精度 ]
comments: true
---
这将是一个巨大的新坑呢，大致是对于最近搞的事儿，高精度整数类的一个简介。

最近因为复习，所以很长时间没有动我C++高精度整数类实现，虽然这是造烂的轮子——各大脚本语言、现代编程语言基本都内置了、甚至默认使用“无穷”精度的整型，不过有时候重造轮子还是有用的，知道一个东西怎么用只是停留在表面，能了解其实现、原理，甚至重现一遍可以加深对它的理解。

这里标题之所以是**多项式**的基本运算，是因为所谓高精度——这里是十进制——其实是多项式中的一个数列元素属于序为10的有限域，还存在进位的特例。其实已经不算多项式了，但是可以类比。或者说，多项式是进制为无穷大的高精度数，完了我也不知道哪个是哪个的特例了。后来的用了压位只是修改了有限域的序，同样的，换进制也可以修改一下有限域的序，这些在后面会有简单介绍。

说到底，数字和多项式就是一串数列啊。

<!-- more -->

## 一元多项式

{::nomarkdown}
一元多项式（后面默认多项式指的是一元多项式，除非有特殊提及）是由一个环上的数列\(\{a_n\}\)和一个满足环上运算的未知量\(x\)非负幂次乘积的和组成的，形式如下的一种函数$$P(x)=a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}+a_nx^n$$

用求和记号简单表示为$$P(x)=\sum_{i=0}^na_ix^i$$

这里的\(n\)并不是一个固定的常数，其可以为\(n\in\mathbb Z_0^+\)的任何值，我们称这里的\(n\)，也就是P的最高次项的次数为多项式\(P\)的度，记为\(\deg P\)。然后，方便起见，我们令\(\{a_n\}\)在后部补0扩充为无穷数列——然后我们来讨论幂级数吧，不过我仍称之为多项式——亦即满足\(\forall i&gt;\deg P:a_i=0\)，则$$P(x)=\sum_{i=0}^\infty a_ix^i$$

{:/nomarkdown}

容易证明，多项式本身也构成一个环，其二元运算符为数列环上的二元运算符。那么接下来就通过证明多项式满足环的性质来讨论多项式的加减乘整除取模运算。


## 多项式的加法

{::nomarkdown}

加法无需多讲，设两个多项式分别为\(A(x)=\sum_{i=0}^\infty a_ix^i\)和\(B(x)=\sum_{i=0}^\infty b_ix^i\)，这里根据环上满足的分配律可以得到$$
\begin{align*}
A(x)+B(x)&=\sum_{i=0}^\infty a_ix^i+\sum_{i=0}^\infty b_ix^i\\
&=\sum_{i=0}^\infty(a_i+b_i)x^i
\end{align*}
$$

这个等式简单地表明了多项式的和就是相应项系数求和，时间复杂度为\(O(n)\)

{:/nomarkdown}

## 多项式的减法

{::nomarkdown}对于减法，首先定义多项式的零元，很简单，令\(a_0=a_1=a_2=\cdots=0\)即可，这里的0是数列所在环上的零元，由于未知量同样满足数列环上的二元运算，且\(0\times x=0\)，\(0+0=0\)，我们得到多项式的零元就是\(O(x)=0\)，注意不要和上面的时间复杂度大O记号搞混，不过零元只会在减法这里出现一次。{:/nomarkdown}

{::nomarkdown}

多项式关于加法运算逆元的定义，和普通环一样都满足\(P(x)+[-P(x)]=O(x)\)，所以实际上就是每一项的值都取负构造成的新多项式为原多项式的逆元，也就是$$
\begin{align*}
-P(x)&=-\sum_{i=0}^\infty a_ix^i\\
&=\sum_{i=0}^\infty-a_ix^i
\end{align*}
$$

由此，可以定义多项式的减法为$$
\begin{align*}
A(x)-B(x)&=A(x)+[-B(x)]\\
&=\sum_{i=0}^\infty a_ix^i+\sum_{i=0}^\infty-b_ix^i\\
&=\sum_{i=0}^\infty(a_i-b_i)x^i
\end{align*}
$$

同样的，复杂度也是\(O(n)\)

{:/nomarkdown}

加法和减法定义完毕，容易证明多项式对于加法运算符共同构成一个交换群，亦即：封闭性、交换律、结合律、零元和逆元，这里就不展开说明了。

## 多项式的乘法

乘法的计算是满足常数项所在的环域交换律的，只是运算比较麻烦。或者说，非常麻烦。定义如下：

{::nomarkdown}
$$
\begin{align*}
A(x)B(x)&=\left(\sum_{i=0}^\infty a_ix^i\right)\left(\sum_{j=0}^\infty b_jx^j\right)\\
&=\sum_{i=0}^\infty\sum_{j=0}^\infty a_ib_jx^{i+j}\\
&=\sum_{k=0}^\infty\left(x^k\sum_{i+j=k}a_ib_j\right)
\end{align*}
$$

在此也顺便可以观察到，因为实际上对于\(k&gt;\deg P+\deg Q\)的情况系数均为0，所以\(\deg AB=\deg A+\deg B\)。另外，朴素的算法复杂度达到\(O(n^2)\)，在处理数据稍大的情况，如项数超过一万位，就明显地感到卡顿，因此在后面会继续讲解一种复杂度为\(O(n\lg n)\)的算法。
{:/nomarkdown}

## 多项式除法

多项式环并不是一个除环，所以实际上并不是每个多项式除法都是封闭的或是有定义的。在这里我只定义带余数的除法，亦即对于两个多项式{::nomarkdown}\(A\)和\(B\)，总存在一对且仅存在一对多项式\(Q\)和\(R\)，其\(\deg R&lt;\deg B\)使得$$A=BQ+R$$成立，则多项式\(Q\)被称为商（quotient），\(R\)被称为余数（remainder）。存在性和唯一性容易证明，这里就不赘述了。{:/nomarkdown}

那么多项式除法和余数就表示为{::nomarkdown}$$A/B=Q\\A\%B=R$${:/nomarkdown}

多项式的除法真是个麻烦的玩意儿，正常运算我们都列竖式（对于LaTeX排版竖式绝望，我决定放弃举例），一般程序中都使用二分法——去你的我就没见过哪个程序实现过，二分法的复杂度爆炸了，这里不讨论。

{::nomarkdown}不过我们仍然可以类似递推出\(Q\)的每一项系数，因为\(\deg A&lt;\deg B\)的情况\(Q=0\)，这里就不考虑了，接下来式子均在\(\deg A\ge\deg B\)下讨论。然后，不妨令\(n=\deg A, m=\deg B\)，设\(Q\)的数列为\(\{q_n\}\)，\(R\)的数列为\(\{r_n\}\)。{:/nomarkdown}

{::nomarkdown}
我们从被除数开始考虑，因为是作为除数和商的积，所以满足上面的乘法，当然，还有最后几位最后成为余数的，于是我们可以得到如下式子$$a_k=\sum_{i+j=k}b_jq_i+r_k$$

仍然，大于度数的数列项这里默认为0。但是我们可以缩小范围以提取出\(q\)数列中的一项，我们根据上文假设\(\deg A\ge\deg B\)知，\(j&gt;\deg B\)时，亦即\(i&lt;k-\deg B\)时，\(b_{k-i}q_i=0\)，不再产生影响，这就使\(i\)的范围缩小了。与此同时，由于\(k&lt;\deg B\)的时候，\(a_k\)的值对于\(q\)不再有影响，则无需再考虑，这样又消去了\(r\)数列：$$a_k=\sum_{i=k-m}^kb_{k-i}q_i\qquad(m\le k\le n)$$

提取出\(i=k-m\)的一项，可以得到：$$
\begin{align*}
b_mq_{k-m}=a_k-\sum_{i=k-m+1}^kb_{k-i}q_i\qquad(m\le k\le n)\\
q_{k-m}=\frac1{b_m}\left(a_k-\sum_{i=k-m+1}^kb_{k-i}q_i\right)\qquad(m\le k\le n)
\end{align*}
$$

哦，看着稍微有点不舒服，我们稍微改一下变量……$$q_k=\frac1{b_m}\left(a_{k+m}-\sum_{i=k+1}^{k+m}b_{k+m-i}q_i\right)$$

好了，已经完工了。不过再细一点点，我们从乘法那里知道\(\deg Q+\deg B=\deg A\)，于是\(\forall k&gt;\deg A-\deg B:q_k=0\)，回头看之前的公式，我们又可以分类讨论了：$$q_k=\frac1{b_m}\left(a_{k+m}-\sum_{i=k+1}^{\max(n-m,k+m)}b_{k+m-i}q_i\right)$$

这样，注意到$$
\begin{align*}
q_{n-m}&=\frac1{b_m}(a_n)\\
q_{n-m-1}&=\frac1{b_m}(a_{n-1}-b_{m-1}q_{n-m})\\
q_{n-m-2}&=\frac1{b_m}(a_{n-2}-b_{m-2}q_{n-m}-b_{m-1}q_{n-m-1})\\
\cdots
\end{align*}
$$
其实我们就构造出了其递推数列。但是同样的，其复杂度也达到了\(O(n^2)\)级别，虽然相比于二分的\(O(n^3\lg n)\)有极大的进步——可喜可贺可喜可贺——但是，当然也有颠覆世界观的算法可以达到\(O(n\lg n)\)复杂度，在说完乘法的优化算法之后会提除法的。
{:/nomarkdown}

## 多项式的取模

{::nomarkdown}除法都已经解决，我们还怕什么膜法，哦不，取模，然而实际上取模运算只能做到将被除数减去商乘以除数，所以也是\(O(n^2)\)应该没什么好说的吧……不过同样的，在后面会用\(O(n\lg n)\)的算法来颠覆世界观。{:/nomarkdown}

不管怎样先扔个公式吧。（逃
{::nomarkdown}
$$R=A-\frac AB\times B$$
{:/nomarkdown}

然后，该讲讲如何让乘法和除法达到线性对数时间的[傅里叶变换](http://blog.xris.co/mathematics/Fourier-transform/)了。
