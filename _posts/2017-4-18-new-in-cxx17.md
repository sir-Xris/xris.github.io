---
title: C++17的新玩具们
layout: post
categories: C-C++
tag: [ cxx ]
comments: true
---

什么？C++11都还没学完，C++17要来了？

作为我第二种学习的编程语言和真・最熟悉的语言，C/C++的标准化进程一直是我很关心的话题，所以在官方放出了C++17相对于C++14的变化的[这篇文档](https://isocpp.org/files/papers/p0636r0.html){:target="_blank"}之后，没日没夜研究了十天，最后恍然大悟——看来我需要回去重学C++11和C++14。

截至开始写这篇文章的时候（2017年4月8日）为止，C++17的标准已经基本定型了，当然，还是无法保证最终标准和现在没有大变化，甚至可能和C++0x一样，最终变成了C++11，但愿别跳。现在正在各个分支上进行更具体的讨论。具体情况可见[官网](https://isocpp.org/std/status){:target="_blank"}。下图是一个简要的工作流。

![](https://isocpp.org/files/img/wg21-timeline-2017-03.png)

<!-- more -->

以下的代码，统统

{% highlight cpp %}
#include <bits/stdc++.h>
using namespace std;
{% endhighlight %}

没错，我用g++，咋啦？代码均经过g++ 6.3.1 20170306和g++ 7.0.1 20170409 (experimental)测试。暂未经过clang++及其它编译器测试。

## 新增的语言特性

C++17作为一次比较重大的更新（不，我不和C++11比，那是一门新语言），加入了不少新的特性。但是我感觉还是语法糖居多，实质性的大变化不多。之前很吸引人的concept，类似于其它语言中的interface概念，并未标准化（尽管大部分编译器已经实现），还有解决C历史遗留的直接`#include`头文件太暴力而引入的module，就是别的语言轻轻松松无条件的`import`和`export`，自从C++0x就已经提上日程，却在开发中。有点令人失望，希望能在C++20中见到它们。

### `noexcept`成为函数类型系统的一部分

[P0012R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html){:target="_blank"}

目的是提升类型安全性。大意是在函数后声明的`noexcept`不同，则函数也不同。举例而言：`void foo() noexcept(true)`和`void bar() noexcept(false)`是两个不同类型的函数。拿文档里的例子来说，在`template <typename Func> func(Func *foo, Func *bar)`中传入`noexcept`不同的函数从C++17开始被视为是不正确的。

值得注意的是，一个`noexcept`函数指针赋值给一个普通函数指针，将变成一个普通`noexcept(false)`函数指针。也就是`void (*foo)() = []() noexcept -> void {}`和`void (*bar)() = []() -> void {}`是一样的类型。而反过来，从普通函数到`noexcept`函数的类型转换在C++17中被禁止，也就不会有一个`noexcept`函数指针指向普通函数的情况。

现在标准委员会的老头子们正在想破脑袋怎么使`function`类实现这个特性。

### `u8`字符串字面值前缀

[N4267](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4267.html){:target="_blank"}

本质还是`const char *`类型，不过增加了一个前缀用于声明是UTF-8字符串。在机子上试验过直接用`"汉字"`和`u8"汉字"`，在C++11及以上的结果都是一样的，不过可能是系统locale设置的原因。个人猜测这个特性是针对`char`储存宽字符默认不是使用UTF-8的编译器增加的显式声明，使用UTF-8储存字符串。

### 十六进制浮点字面值

[P0245R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0245r1.html){:target="_blank"}

支持了自C99引入C语言的特性。大概格式为`[+-]?0[xX][0-9a-fA-F]*\.?[0-9a-fA-F]*[pP][+-]?\d+[lf]`。这个正则还不是很规范，因为可能有十六进制数字一个都没有，或者仅有一个小数点的情况，这都是非法的，所以真要写全还要再重复至少一遍，这个理解就行。

前缀的`[+-]?`没什么好解释的，`0[xX]`是声明为16进制数字，`[0-9a-fA-F]*\.?[0-9a-fA-F]*`表示在小数点前后有任意多个16进制数字，当然两边总共至少要有一个，或者直接小数点不存在。`[pP]`为底和幂的分隔符，这在16进制浮点书中是必须有的，。然后后面再跟一串十进制数字，后缀的`[lf]`是浮点型类型后缀，一个是`long double`一个是`float`。

### 折叠表达式

[N4295](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4295.html){:target="_blank"}
[P0036R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0036r0.pdf){:target="_blank"}

一个令人兴奋的新特性（语法糖？），讲得有点多。

虽然说从C开始就已经有了省略号操作符，但是必须要传入参数的个数（或者像`printf`一类一样传入格式），以及`va_list`一类并不优雅的宏。C++03本来没有自己的可变参数方法，直到C++11开始引入可变参数模板，可以实现比`...`操作符更优美的可变参数，而17更进一步，支持直接对可变参数的参数进行内置运算。

在C++11里，可变参数没有简单的方式扩展参数，需要模板有一个分离开的参数和可变参数模板，重载一个递归终点（模板元编程常见套路），然后递归调用自身。这种方法仍然有很大局限性，比如难以重载多个类型的相同功能函数。

另一种方法是在initialize list里手动显式展开参数包来初始化，这个主意我还能接受，当然，同样也有局限性。

还有一些方法，这里不再另外举例，详见[维基百科](https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF){:target="_blank"}。总之，因为无法对参数包进行迭代，可变参数从一开始就是个麻烦的活。大概是因为的tuple不是默认而是STL里的附加类型，而且template和range for一个是编译时一个是运行时，无法同时使用，所以最后就这么留下了坑吧，算是一个不小的遗憾。

到了C++17，有了折叠表达式，某些运算的展开就变得非常的优雅了，也能支持各种类型。尽管还是无法对参数包进行迭代，对于其他非中缀双目函数，无法展开，如果需要求一串数据的最大值，可能还是需要用到上面提到的C++11的老方法。

下面是几个二元运算符展开可变参数模板类的例子。

{% highlight cpp %}
template <typename ...Args>
auto sum(Args ...args) {
  return (args + ...);
}

template <typename ...Args>
void print(Args ...args) {
  (cout << ... << args) << endl;
}

template <typename T, typename ...Args>
void push(vector<T> v, Args ...args) {
  (v.push_back(args), ...);
}
{% endhighlight %}

无比震撼。

在C++17里，折叠表达式的运算符可以有所有的算数运算、位运算、逻辑运算，以上运算的带赋值版本甚至还有逗号运算和类成员指针操作符（似乎可以用在数据结构里？）。当然，如果传入的可变模板是空的的话，这些运算的计算结果均为其（群论意义上的）单位元。

### 模板参数类型推导

<small>`auto`解决一切</small>

[P0127R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0127r2.html){:target="_blank"}

就是`template <auto value>`，value的类型可以直接由编译器推导。配合上`if constexpr`、可变参数和折叠表达式似乎可以干很多事情？

### 模板类参数推导

<small>连`auto`都不需要</small>

[P0091R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html){:target="_blank"}
[P0433R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0433r2.html){:target="_blank"}
[P0512R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0512r0.pdf){:target="_blank"}
[P0620R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0620r0.html){:target="_blank"}

我的天呐终于有这个特性了，以前定义一个模板类的实例真的要写一堆，以至于每次看别人代码都是`typedef pair<int, int> pii`，哇丑爆了。一直在想既然重载函数可以自动推导是哪个对应的，为什么类就不行？

举个简单的例子，以前定义一个`pair`必须要有`pair<char const *, int> p = {"answer", 42}`，而现在可以省去模板声明，直接`pair p = {"answer, 42}`，剩下的类型推导还是由编译器来做。

### 常量表达式if

[P0292R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0292r2.html){:target="_blank"}

加入了针对template参数的编译期判断的条件表达式。语法就是`if constexpr(cond) { } else { }`。

也就是对模板参数而言不必构造特例来进行特殊操作，可以直接在函数里进行判断。<del>比如模板元编程里的递归终点可以用常量if判断，相比以前的形式增强了可读性。</del>试了一下并不能直接写在类里，坑货，还是要手动重载递归终点。那就只能在函数里用了，这个特性大概是用来替代`#if`, `#else`等等的宏的吧。

### 带初始化的条件分支

<small>压代码新技能</small>

[P0305R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r1.html){:target="_blank"}

语法糖。很多新语言（Go、Swift）里都实现了这个功能，也是我在C++17中第一个关注到的新特性。简单说就是`if`和`switch`语句增加了和`for`循环类似的初始化语句。下面是两个例子

{% highlight cpp %}
if (auto it = m.find(key); it != m.end()) {
  /* do something with it */
} else {
  /* it is still alive */
}
{% endhighlight %}

{% highlight cpp %}
switch (auto r = requests.get(url); r.status_code) {
  case 200: /* ... */ break;
  case 302: /* ... */ break;
  case 404: /* ... */ break;
  case 500: /* ... */ break;
  default:  /* ... */ break;
}
{% endhighlight %}

### 常量匿名函数

[P0170R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0170r1.pdf){:target="_blank"}

Lambda表达式可以声明为常量表达式。语法是`[]() constexpr -> return {}`。

### 匿名函数捕获`*this`

[P0018R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0018r3.html){:target="_blank"}

Lambda表达式`*this`可以作为关键字直接捕获，而不必在方括号里传入`this`。

比如原来在类成员函数里使用Lambda表达式需要以`[this]() { this->foo(); }();`把`this`作为一个普通变量捕获，或者以更麻烦的形式传入this，C++17里可以直接传入`*this`，可以写作`[*this]() { foo(); }()`而不需要`this->`。

### 内联变量

[P0386R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf){:target="_blank"}

简单来讲，本来定义一个类内的静态常量需要先在类内声明（且仅能声明无法定义），然后全局定义，现在可以直接类内内联定义，不需要多次定义。顺了个便，把声明和定义分开的行为开始定义为不再建议使用（见最下）。

前几天刚被旧标准活活坑了一把，结果没过几天就听说新的标准将这种行为规范化了。

### 结构绑定

<small>从此支持"多返回值"函数一句话赋值</small>

[P0217R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0217r3.html){:target="_blank"}
[P0615R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0615r0.html){:target="_blank"}

语法糖。又是一个从别的语言模仿过来的特性。返回的值可以直接赋值给绑定到临时的`pair`或`tuple`里的直接定义的单独的变量。这些变量是直接定义的也就意味着无法利用这个方法让已定义的变量接受返回值。比如说一个，做到（不显式）定义新变量达到变量交换，也就是无法通过类似Python或Go里的`x, y = y, x`这样交换变量。

鉴于C++11引入了`tuple`，这个本来直接让程序员操作也不难了（就是有点麻烦，需要一个一个取值），然后又加了一块语法糖而已。C++相对其它语言，想要直接捕获多返回值还是需要定义新变量，用一个方括号包裹，但是真的，对于C++而言这已经很优雅了。

我以前不会Lambda表达式的时候也觉得——C++的Lambda表达式真难看啊，现在越看越顺眼。（说来，方括号有这么多语义真是辛苦编译器和编译器作者了）

{% highlight cpp %}
auto [x, y] = pair(true, "love");
assert(x == true);
assert(y == "love");
cout << boolalpha << x << ' ' << y << '\n';
{% endhighlight %}

### 预处理关键字`__has_include`

<small>try impor    t except else finally</small>

[P0061R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0061r1.html){:target="_blank"}

`__has_include`检查存不存在某个头文件，比如

{% highlight text %}
#if __has_include(<getopt.h>)
# include <getopt.h>
#elif __has_include("getopt.h")
# include "getopt.h"
#else
# error No getopt.h found in system
#endif
{% endhighlight %}

### 三个标准attribute

<small>是什么让你产生了程序员会看warning的错觉？</small>

C++11引入的，用于规范编译器自带的attribute的特性。以下为三个新增的标准attribute。

* [`[[fallthrough]]`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r1.pdf){:target="_blank"} 加在`case`的`break`位置，使得编译器发现`switch`中某个`case`执行了操作而没有`break`之后也不给出警告。
* [`[[nodiscard]]`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0189r1.pdf){:target="_blank"} 放在一个类型声明的时候，如果一个函数返回了这个类型实体而不处理返回值编译器将会给出警告。
* [`[[maybe_unused]]`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0212r1.pdf){:target="_blank"} 告诉编译器某个实体可能不被使用，不需要给出警告。放在变量声明的类型前。

### 内存清洗`launder()`

[P0137R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0137r1.html){:target="_blank"}

并不知道官方中译，我自己随便写了个内存清洗。这个函数在`std::`下。自己也不清楚用处在哪里，看了点资料，还是用官方文档的解释一下比较好。代码，自己戳进去看。

自己的理解是带有const的实例，可能会被编译器优化直接硬编码，结果内存里重新new的之后这片空间重新分配了const变成了另一个const，如果有另一个指向这片区域的指针或引用再次取值是未定义行为。所以用`std::launder`“清洗内存”重新取值（为什么有种`volatile`的感觉？）。

除此之外，改变了一块内存的类型的时候也应当使用`std::launder`。

### 类型（名）`byte`

<small>委员会：我觉得`unsigned char`太长了我懒得打，我们换个短点的名字吧</small>

[P0298R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0298r3.pdf){:target="_blank"}

{% highlight cpp %}
namespace std {
typedef unsigned char byte;
}  // std
{% endhighlight %}

这个定义实现在`cstddef`头文件的`std`命名空间里，除了定义之外还有很多运算符的重载。另外注意这是C++标准，不是C标准，所以只有C++17里有，C里现在还没有这个新关键字，等C新标准吧（如果有的话）。

增加`byte`是为了区分和`unsigned char`之间的语义差别。

## 新的库特性

库方面，比较有名的是增加了很多数学函数、文件系统filesystem库和并行parallel库，但是很令人可惜的是并发cocurrency库、网络networking库都还没加入标准。

### 大量的数学函数

<small>开发者表示这都是些啥</small>

[P0226R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0226r1.pdf){:target="_blank"}

之前加入到ISO标准（ISO/IEC 29124:2010）的一系列函数被正式加入了C++。还是放在cmath的std命名空间下。同样的，这是C++标准，不是C标准。

所有的函数都有三个类型的名字和重载，默认是`double`的返回值，有一个没有后缀的函数名，对于`float`和`long double`分别有`f`和`l`为后缀。无后缀的类型对于其它的传入类型都有重载，除了同时传入`float`或同时传入`long double`返回都是`double`外，其它的返回类型是两者中精度较高的类型，而传入`integer`类型时均会被提升为`double`。

|`expint(x)`|[指数积分](https://en.wikipedia.org/wiki/Exponential_integral){:target="_blank"}|$$\displaystyle{\mathrm{Ei}(x)=-\int_{-x}^\infty\frac{\mathrm e^{-t}}t\,\mathrm dt}$$|
|`reimann_zeta(s)`|[黎曼$$\zeta$$函数](https://en.wikipedia.org/wiki/Riemann_zeta_function){:target="_blank"}|$$\displaystyle{\zeta(s)=\sum_{n=1}^\infty\frac1{n^s}}$$|
|`beta(x, y)`|[$$Β$$函数](https://en.wikipedia.org/wiki/Beta_function){:target="_blank"}|$$\displaystyle{Β(x,y)=\int_0^1t^{x-1}(1-t)^{y-1}\,\mathrm dt}$$|
|`ellint_1(k, phi)`|[第一类不完全椭圆积分](https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_first_kind){:target="_blank"}|$$\displaystyle{F(k,\varphi)=\int_0^\varphi\frac{\mathrm d\theta}{\sqrt{1-k^2\sin^2\theta}}}$$|
|`comp_ellint_1(k)`|[第一类完全椭圆积分](https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_first_kind){:target="_blank"}|$$\displaystyle{K(k)=\int_0^{2\pi}\frac{\mathrm d\theta}{\sqrt{1-k^2\sin^2\theta}}}$$|
|`ellint_2(k, phi)`|[第二类不完全椭圆积分](https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_second_kind){:target="_blank"}|$$\displaystyle{E(k,\varphi)=\int_0^\varphi\sqrt{1-k^2\sin^2\theta}\,\mathrm d\theta}$$|
|`comp_ellint_2(k)`|[第二类完全椭圆积分](https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_second_kind){:target="_blank"}|$$\displaystyle{E(k)=\int_0^{2\pi}\sqrt{1-k^2\sin^2\theta}\,\mathrm d\theta}$$|
|`ellint_3(k, phi)`|[第三类不完全椭圆积分](https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_third_kind){:target="_blank"}|$$\displaystyle{\Pi(k,n,\varphi)=\int_0^\varphi\frac{\mathrm d\theta}{(1-n\sin^2\theta)\sqrt{1-k^2\sin^2\theta}}}$$|
|`comp_ellint_3(k)`|[第三类完全椭圆积分](https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_third_kind){:target="_blank"}|$$\displaystyle{\Pi(k,n)=\int_0^{2\pi}\frac{\mathrm d\theta}{(1-n\sin^2\theta)\sqrt{1-k^2\sin^2\theta}}}$$|
|`hermite(n, x)`|[埃尔米特多项式](https://en.wikipedia.org/wiki/Hermite_polynomials){:target="_blank"}|$$\displaystyle{H_n(x)=(-1)^n\mathrm e^{x^2}\frac{\mathrm d^n}{\mathrm dx^n}\mathrm e^{-x^2}}$$|
|`laguerre(n, x)`|[拉盖尔多项式](https://en.wikipedia.org/wiki/Laguerre_polynomials){:target="_blank"}|$$\displaystyle{L_n(x)=\frac{\mathrm e^x}{n!}\frac{\mathrm d^n}{\mathrm dx^n}(\mathrm e^{-x}x^n)}$$|
|`assoc_laguerre(n, m, x)`|[广义拉盖尔多项式](http://en.wikipedia.com/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials){:target="_blank"}|$$\displaystyle{L_n^m(x) = \frac{x^{-m}\mathrm e^x}{n!}\frac{\mathrm d^n}{\mathrm dx^n}(\mathrm e^{-x}x^{n+m})}$$|
|`legendre(n, x)`|[勒让德多项式](https://en.wikipedia.org/wiki/Legendre_polynomials){:target="_blank"}|$$\displaystyle{P_n(x)=\frac1{2^nn!}\frac{\mathrm d^n}{\mathrm dx^n}(x^2-1)^n}$$|
|`assoc_legendre(n, m, x)`|[广义勒让德多项式](https://en.wikipedia.org/wiki/Associated_Legendre_polynomials){:taget="_blank"}|$$\displaystyle{P_n^m(x)=\frac{(-1)^m}{2^nn!}(1-x^2)^{m/2}\frac{\mathrm d^{n+m}}{\mathrm dx^{n+m}}(x^2-1)^n}$$|
|`sph_legenre(l, m, theta)`|[球勒让德多项式](javascript:void(0))|$$\displaystyle{Y_\ell^m(\theta,\varphi=0)=(-1)^m\sqrt{\frac{2\ell+1}{4\pi}\frac{(\ell-m)!}{(\ell+m)!}}P_\ell^m(\cos\theta)\mathrm e^{\mathrm im\varphi}}$$
|`cyl_bessel_j(alpha, x)`|[第一类贝塞尔函数](https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1){:target="_blank"}|$$\displaystyle{J_\alpha(x)=\sum_{m=0}^\infty\frac{(-1)^m(x/2)^{2m+\alpha}}{m!\Gamma(m+\alpha+1)}}$$
|`cyl_bessel_i(alpha, x)`|[第一类修正贝塞尔函数](http://en.wikipedia.com/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1){:target="_blank"}|$$\displaystyle{I_\alpha(x)=\sum_{m=0}^\infty\frac{(x/2)^{2m+\alpha}}{m!\Gamma(m+\alpha+1)}}$$
|`sph_bessel(n, x)`|[第一类球贝塞尔函数](https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn){:target="_blank"}|$$\displaystyle{j_n=\sqrt{\frac\pi{2x}}J_{n+\frac12}(x)}$$
|`cyl_neumman(alpha, x)`|[第二类贝塞尔函数（诺依曼函数）](https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_second_kind:_Y.CE.B1){:target="_blank"}|$$\displaystyle{Y_\alpha(x)=\frac{J_\alpha(x)\cos(\alpha\pi)-J_{-\alpha}(x)}{\sin{\alpha\pi}}}$$
|`cyl_bessel_k(alpha, x)`|[第二类修正贝塞尔函数](http://en.wikipedia.com/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1){:target="_blank"}|$$\displaystyle{K_\alpha(x)=\frac\pi2\frac{I_{-\alpha}(x)-I_\alpha(x)}{\sin(\alpha\pi)}}$$
|`sph_neumann(n, x)`|[球诺依曼函数](http://en.wikipedia.com/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn){:target="_blank"}|$$\displaystyle{y_n=\sqrt{\frac\pi{2x}}Y_{n+\frac12}(x)}$$

### 文件系统`<filesystem>`

[P0218R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0218r0.html){:target="_blank"}
[P0219R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0219r1.html){:target="_blank"}
[P0317R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0317r1.html){:target="_blank"}
[P0392R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0392r0.pdf){:target="_blank"}
[P0430R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0430r2.pdf){:target="_blank"}
[P0492R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0492r2.html){:target="_blank"}

标准化系统对于文件操作的接口。直接来自于`boost::filesystem`，很大程度上基于POSIX标准，然而其灵活性足以在多个系统上移植。

可以对文件进行各种操作，比如创建各种类型的文件，目录、文件迭代，复制粘贴，删除文件等等。鉴于正式的文档比较缺乏，可以先参考一下boost的`boost::filesystem`文档，类和函数上和标准库没有区别。唯一的区别在于，boost的文件系统直接输出`path`而转为字符串再输出的escape字符是`&`而非`\`。

### 并行算法库`<execution>`

[P0024R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html){:target="_blank"}
[P0336R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0336r1.pdf){:target="_blank"}
[P0394R4](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0394r4.html){:taget="_blank"}
[P0452R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0452r1.html){:target="_blank"}
[P0467R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0467r2.html){:target="_blank"}
[P0502R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0502r0.html){:target="_blank"}
[P0518R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0518r1.html){:target="_blank"}
[P0523R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0523r1.html){:target="_blank"}
[P0574R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0574r1.html){:target="_blank"}
[P0623R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0623r0.html){:target="_blank"}

增加了对各种并行算法的支持，有三种执行策略（execution_policy），分别是`execution::seq`(sequenced)、`execution::par`(parallel)和`execution::par_unseq`(parallel unsequenced)。我看不懂，就不强行解释了。

这三个类的主要用途是在原来的一些函数中传参进去，比如`sort`，用`sort(execution::par, v.begin(), v.end())`的方法使用。新增这一重载的函数均包括在`<algorithm>`和`<numeric>`里。数量非常多，只要你能想到的序列操作的函数，全部都有这个的重载。当然也包括几个C++17新增的函数，也有这个的重载，这个在下面立刻就会提到。

然而很可惜的，至今为止gcc和clang均还没有完全实现这个特性，即使是正在开发中的版本，也没有这个库的实现，所以我暂时没能测试这个库。啊哈，vsc++是个什么远古编译器？

### 新算法

<small>配合并行库口味更佳</small>

[P0024R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html){:target="_blank"}

为`<numeric>`新增了不少的算法，`<algorithm>`里也有一个。下面的函数都有很多的重载，这里挑选最一般的，而且每个函数都包含一个第一个参数是并行算法参数的重载，下面没有写进去。

* `for_each_n`，`for_each`的给出长度版本。
* `reduce`，和`accumulate`一样，只是不保证运算顺序。
* `transform_reduce`，先对参数执行一次`transform`，再进行一次`reduce`。
* `inclusive_scan`，（前缀和里的）前缀运算，`inclusive`为运算结果中的第i项包含和原数列第i项运算结果。
* `exclusive_scan`，（前缀和里的）前缀运算，`exclusive`为运算结果中的第i项不包含和原数列第i项运算结果。
* `transform_inclusive_scan`，先进行一次`transform`再`inclusive_scan`。
* `transform_exclusive_scan`，先进行一次`transform`再`exclusive_scan`。

### 类`string_view`和`basic_string_view`

[P0220R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html){:target="_blank"}
[P0254R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0254r2.pdf){:target="_blank"}
[P0403R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0403r1.html){:target="_blank"}

所谓的immutable变量。和`string`一样，只是不能改变其中的元素。字面值常量用`operator ""sv`重载了一把，也就是这种`"xris"sv`就是其字面值常量。其它的好像是没什么好说的。

### 类`any`

<small>动，动态类型？</small>

[P0220R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html){:target="_blank"}
[P0032R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf){:target="_blank"}
[P0504R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0504r0.html){:target="_blank"}

“任意”类型，可以保存任何类型，给`any`类型的东西赋任何类型的值，感觉比下面那个更加强大。只是在取值的时候需要解析，可以用成员函数`type`获取其保存类型的`typeid`，`any_cast`获取某个类型的值，如果类型无法提取出来（不匹配或无法转换）直接抛出`bad_any_cast`错误。

用作返回值的时候，可以做到——如果程序执行成功，返回一个类型，否则返回另一种类型这样看起来很魔幻的黑魔法。

### 类模板`variant`

<small>类型安全的`union`</small>

[P0088R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html){:target="_blank"}
[P0393R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0393r3.html){:target="_blank"}
[P0032R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf){:target=:_blank"}
[P0504R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0504r0.html){:target="_blank"}

`variant<...types>`，一个类型的集合，可以随便选择其中一种类型赋值，似乎C++17就特别想做一个动态语言吼？官方的介绍是"A type-safe union for C++17"。

赋值会自动判断类型，直接给里面的某个类型赋值。取值的时候，选择一种类型取值，如果没有该类型则抛出异常，如果并不知道返回了什么，有个标准库函数`visit`实现了访问一个`variant`所有类型的操作，其第一个参数为操作函数，第二个是`variant`变量。

### 类模板`optional`

[P0220R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html){:target="_blank"}
[P0307R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0307r2.pdf){:target="_blank"}
[P0032R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf){:target=:_blank"}
[P0504R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0504r0.html){:target="_blank"}

`optional<T>`可以视为一个`variant<T, nullopt_t>`，其值非空即为一个`T`类型的值。给一些不能作为`nullptr`的值提供了设置为空的可能。

明显从Java 8、Swift抄的`Optional`嘛，然而讲道理，这个相对前面两者还是弱了，比较重要的函数是`.value_or()`，如果为空返回成员函数里传入的参数。

### 函数`invoke`

<small>调用函数的函数</small>

[N4169](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4169.html){:target="_blank"}

`invoke`可以直接调用成员函数传入参数，`invoke(fn, ...args)`的形式，调用任何可调用的（`is_invocable`）的物件——`function`类、函数指针等等很多东西。

好了问题来了，`invoke`可以`invoke`自己吗？

### traits `is_invocable`

<small>所以`invoke`是不是`is_invocable`</small>

[P0077R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r2.html){:target="_blank"}
[P0604R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html){:target="_blank"}

第一份文档里叫做`is_callable`，已经更名为`is_invocable`的几个，具体见第二篇里的投票。

为上面的`invoke`定义的一些模板和类型。顾名思义，`is_invocable`是一个判断物件可不可（这里是要传入所有参数判断能否）调用的模板类，`is_invocable_r`是物件可调用，且返回结果可转化为类型`r`。还有两个`is_nothrow_invocable`和`is_nothrow_invocable_r`也是顾名思义。

文档中还提到了对`invoka_result`名称的投票，是返回值类型的意思。

### 函数`to_chars`和`from_chars`

<small>闻到了一点Python的味道</small>

[P0067R5](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0067r5.html){:target="_blank"}

介绍了`<utility>`库中的两个新函数`to_chars`和`from_chars`，顾名思义。

它们的返回值分别是`struct to_chars_result { char *ptr; std::error_code ec; };`和`struct from_chars_result { char *ptr; std::error_code ec; }`，看起来一点区别都没有。

`to_chars(char *begin, char *end, integer value, int base = 10)`，可以转换一个整型为字符串到`[begin, end)`区间里，base需要在2~36之间，大于9的以字母替代。如果转换失败（区间太短），其返回值的`ec`会被赋值为`errc::value_too_large`。

除此之外还有对于浮点数字的转换以及提供其它形式参数，比如hex的转换，不一一介绍。

大概是觉得`sprintf`和`sscanf`不够安全所以另外定义了一个吧。

### 模板类`void_t`

[N3911](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3911.pdf){:target="_blank"}

提供了`void`的别名，在模板元编程里对于SFINAE非常实用，相对于苦心构造编译失败，这个提供了更方便的方法。摘抄一段[cppref](http://en.cppreference.com/w/cpp/types/void_t){:target="_blank"}的代码说明一下。

{% highlight cpp %}
template <typename T, typename = void>
struct is_iterable : false_type {};
template <typename T>
struct is_iterable<T, void_t<decltype(declval<T>().begin()),
                             decltype(declval<T>().end())>>
    : true_type {};
{% endhighlight %}

这就实现了根据存不存在`begin()`和`end()`成员函数判断能否迭代。

### 模板类`bool_constant`

[N4389](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4389.html){:target="_blank"}

`bool_constant`是`integral_constant`的`typename`为`bool`的特化，而C++11的`true_type`和`false_type`是`bool_constant`的对应`true`和`false`的特化。所以没什么好说吧。

### 模板类的逻辑运算

[P0013R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html){:target="_blank"}

起源似乎是libstdc++里的`__and_`、`__or_`和`__not_`，人们感觉这东西真好用，于是标准化了。标准化后的名字为`conjunction<...Bool>`, `disjunction<...Bool>`和`negation<Bool>`，分别对应与或非。同样的，结果在其成员`::value`中，后缀加了`_v`的，直接分别等于它们三个的`::value`。

### traits `is_swappable`

[P0185R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0185r1.html){:target="_blank"}

包含了对于一个或两个类型能不能直接`swap`的检查的几个模板类：`is_swappable`, `is_nothrow_swappable`, `is_swappable_with`, `is_nothrow_swappable_with`。顾名思义，`is_swappable`是针对两个相同类型的，`is_swappable_with`是针对两个不同类型的。和往常一样，结果储存于`::value`下，也可以通过在后面加后缀`_v`获取。

### traits `is_aggregate`

[LWG 2911](http://cplusplus.github.io/LWG/lwg-defects.html#2911){:target="_blank"}

主要是告诉调用者能否使用列表初始化。和其它traits一样的用法，`::value`为返回结果，和加个`_v`后缀是等效的。

### traits `has_unique_object_representations`

<small></small>

[P0258R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0258r2.html){:target="_blank"}

一句话解释是这个东西判断一个类的对象表示和值表示是否一一对应，然而还有对象表示和值表示这个（对我而言的）新概念。那就不讲了。它的用处是判断一个类在`hash`中能否直接以字节数组来进行哈希。

试了试几个简单的东西，一个是一个类里不能有内存对齐存在的padding，不能有虚函数，不能有用户自定的拷贝构造函数，以及其基类也要满足这些条件，才有可能是true，当然也有可能有其它情况，我也没完全搞明白。

### 函数`as_const`

<small>返回原实体的常量引用</small>

[P0007R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0007r1.html){:target="_blank"}

接受左值引用，传出其`const`引用，然而两者指向的实体还是同一个没有变化，也就是说改变前者的同时会改变后者里的值。

另一边，显式声明了对于传入为右值的时候是`= delete`，也就是不让你传入右值。

### 非成员函数的`size`, `data`, `empty`

[N4280](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4280.pdf){:target="_blank"}

重新定义了一下全局的`begin`和`end`两个函数，类型声明增加了`constexpr`。还有几个新增的类似的函数，有`size`, `data`, `empty`。

### 函数`clamp`

<small>是saber的台钳！</small>

[P0025R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0025r0.html){:target="_blank"}

`clamp(value, min_value, max_value)`，要求三者的类型相同。如果`value`在`min_value`和`max_value`之间（包含），那么返回的是`value`，如果大于`max_value`则返回`max_value`，如果小于`min_value`则返回`min_value`。

### 函数`gcd`和`lcm`

[P0295R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0295r0.pdf){:target="_blank"}

`gcd` for Greatest Common Divisor, `lcm` for Least Common Multiple。最大公约数和最小公倍数，大约没什么好说的。

### 共享锁`shared_mutex`

[PN4508](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4508.html){:target="_blank"}

在头文件`<shared_mutex>`中。

`shared_mutex`可以做到`mutex`能做到的读写互斥，也可以做到只有写互斥，成员函数`lock`, `try_lock`, `unlock`实现和`mutex`一样的功能，`lock_shared`, `try_lock_shared`, `unlock_shared`实现只有写互斥。

### 常量`hardware_constructive_interference`, `hardware_destructive_interference_size`

[P0154R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0154r1.html){:target="_blank"}

在头文件`<new>`中。硬件相关的常量，CPU一级缓存块的大小。对硬件了解不够，不强行介绍。官方文档里表示这两个常量也是为多线程准备的。

### 函数`apply`

[P0220R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html){:target="_blank"}

`apply(Fn, Tupl)`第一个参数是一个函数，第二个参数是一个支持`get`和`tuple_size`的东西，标准库里有`array`, `pair`和`tuple`三个，然后将其中的值作为参数传入函数。

还记得，我们可以返回`tuple`类型对吧。

### 函数`make_from_tuple`

[P0209R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0209r2.pdf){:target="_blank"}

和`apply`差不多，不过`make_from_tuple<T>(Tupl)`直接从传入的`tuple`（或其它支持`get`和`tuple_size`的模板类）构造某个类型实例，`make_from_tuple`需要一个模板参数提供返回类型，一个函数参数提供传入的`tuple`。

### 函数`not_fn`

<small>继承`not1`和`not2`的遗志</small>

[P0005R4](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0005r4.html){:target="_blank"}
[P0358R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0358r1.html){:target="_blank"}

和`bind`差不多，都是在C++11引入了可变参数模板后，新定义的用以替代以前C++03年代存在的一系列只针对一元、二元函数的定义的函数的一般化。就是返回一个原函数返回值的取反。

### 内存资源管理库 `<memory_resource>`

<small>委员会：我觉得我们可以把C语言的一切都封装一遍</small>

[P0220R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html){:target="_blank"}

提供了堆内存的封装，头文件里包含了三个类型`synchronized_pool_resource`, `unsyncronized_pool_resource`, `monotonic_buffer_resource`。可以让用户自由选择内存来源，当然默认，或者说最上游内存来源都是物理存储区域。

我只是在想本来内存就不快了，接着封装不会更慢吗。难道是我理解错了？

### allocator `polymorphic_allocator`

[P0220R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html){:target="_blank"}
[P0337R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0337r0.html){:target="_blank"}

使用了内存资源的`allocator`，所以多态是什么意思？仅仅是因为内存来源不同导致结果不同而被称之为多态？

大概是用来替换最后提到的`get_temporary_buffer`用的吧？

### 搜索函数优化算法

<small>KMP是什么辣鸡算法</small>

[P0220R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html){:target="_blank"}
[P0253R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0253r1.pdf){:target="_blank"}

C++17中，`search`函数除了新增加了并行算法，还增加对于不同算法的重载。保留默认的`default_searcher`和两种新的算法的类`boyer_moore_search`, `boyer_moore_horspool_search`。其时间复杂度和KMP一样是$$O(m+n)$$，有常数上的优化。但是两者的最差空间复杂度都激增到了$$O(mn)$$，平均空间复杂度前者还是$$O(mn)$$，后者为$$O(m+n)$$。

传入时用`search(begin(str), end(str), default_searcher)`或者用其它搜索类。

## 改动的特性

### 单个参数的`static_assert`

[N3928](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3928.pdf){:target="_blank"}

不需要再在第二个参数声明错误信息。文档里最下面几行引用别人的评价真的是蜜汁喜感。

### 嵌套namespace声明

<small>委员会：哎呀懒得写了，新增个标准吧</small>

[N4230](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4230.html){:target="_blank"}

不像以前对于每层`namespace`都需要一一声明，现在可以直接用`namespace foo::bar {}`替代`namespace foo { namespace bar { } }`

### 允许在template套template后参数使用`typename`

<small>这回模板参数里的`class`和`typename`是真的没区别了</small>

[N4051](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4051.html){:target="_blank"}

以前只能用`template <template <typename> class Tmplt>`，而新标准可以直接用`template <template <typename> typename Tmplt>`。

### range for对于`begin`和`end`返回类型不再要求相同

[P0184R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0184r0.html){:target="_blank"}

如题，为了将来的Range准备的特性。

### 简化enum变量的定义

<small>现在还有谁说enum不是整型？</small>

[P0138R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0138r2.pdf){:target="_blank"}

可以直接给枚举类型变量赋值为整数，自动转换为枚举类型对应的值。原标准不允许。

### `uncaught_exceptions`

<small>就比原来的函数多了个`s`？</small>

[N4259](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4259.pdf){:target="_blank"}

原来的`uncaught_exception`已经不再建议使用，其返回值是是否有未捕捉的异常，新函数返回值是未捕捉的异常的数量。

### namespace和enum的attribute

<small>委员会：既然各大编译器都已经有了，那就加到标准里吧</small>

[N4266](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4266.html){:target="_blank"}

可以为namespace和enum添加attribute了。加在名字后面。

### attribute的`using`语句

<small>`using`现已无敌</small>

[P0028R4](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0028r4.html){:target="_blank"}

在一个attribute里使用`using`可以直接对整个attribute里生效，无须重复。这些一般是为编译器自家的attribute准备的，毕竟标准attribute没有`::`这种东西。

### `map`的几个新函数

[N4279](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html){:target="_blank"}

对于`map`增加了`try_emplace`和`insert_or_assign`成员函数，顾名思义。

不过我总觉得`try_emplace`和`emplace`没什么区别，也许区别在于`try_emplace`在定义的时候分离出了键值参数，于是键值对应的值可以直接通过可变参数模板的展开来进行构造（之前的`make_from_tupe`类似），否则需要手动包裹成`pair`或`tuple`是挺麻烦的。

`insert_or_assign`，和直接`map`插入的区别有不需要构造一个`pair`传入，它的`first`和`second`两个成员分离成了两个参数。另外返回值是一个`pair<iterator, bool>`，`iterator`指向插入的元素，这个`bool`则说明是insert还是assign，如果是插入则为true，否之为false。至于返回值的接收的话，可以用结构绑定来简化一下代码。

### `emplace_front`和`emplace_back`返回值

[P0084R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0084r2.pdf){:target="_blank"}

`emplace_front`和`emplace_back`返回值为插入地点的迭代器引用。于是我们可以直接对插入的值进行一些操作，用在循环、分支的初始化语句里也方便很多。

### `map`、`set`的合并操作

[P0083R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf){:target="_blank"}
[P0508R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0508r0.html){:target="_blank"}

分别新增加了两个`map`, `set`和它们的`multi`版、`unorder`版的成员函数以及一个对应返回类型的节点类。

* 函数`extract`接收参数为的迭代器或者值，从原结构中删去对应节点并返回。
* `merge`接收另一个类型相同（`unorder`和`order`互相也可）的结构并合并。

### 函数`string::data`增加非常量返回值

[P0272R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0272r1.html){:target="_blank"}

使用C风格字符串的时候方便了一些。原返回值是`const char *`，在一些要求使用`char *`的函数里，并不能从`const char *`转化回它，所以只能另外开辟内存，现在免去。

文档中的例子是用了Windows的API。

### 新类型`scoped_lock`支持多重锁

[P0156R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0156r0.html){:target="_blank"}
[P0156R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0156r2.html){:target="_blank"}

文档里说就是`lock_guard`的可变参数列表的形式，可以一次锁上多个锁，不过鉴于改变太大（看不出来）所以另外取了个名字叫做`scoped_lock`。

### 为一系列traits增加后缀`_v`

<small>委员会：我觉得`::value`太长了一点</small>

[P0006R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0006r0.html){:target="_blank"}

就是将这个特性扩展到了几乎所有的traits。后缀`_v`即为`::value`。

### 静态成员常量`is_always_lock_free`

[P0152R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0152r1.html){:target="_blank"}

似乎又是硬件层面的常量，用以确保是否任意原子操作都是无须锁。似乎之前在查阅资料就看到StackOverflow上提问为什么`is_lock_free`不做成一个常量……于是现在常量来了。

### `shared_ptr`支持数组

[P0220R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0414r2.html){:target="_blank"}
[P0414R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0414r2.html){:target="_blank"}

倒不是说之前不支持，只是之前想要指向数组，还需要手动在第二个参数传入自定的数组删除器`delete[]`，当然必须以类封装。现在自动推导了，直接和`unique_ptr`类似，`shared_ptr<int[]> p(new int[10]);`都是可以了的。

### `shared_ptr::weak_type`

<small>委员会：我懒得翻回去看我之前打的`shared_ptr`的参数类型了，不如直接定义在`shared_ptr`里好了</small>

[P0163R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0163r0.html){:target="_blank"}

什么都没有，就是一个`typedef weak_ptr<T> weak_type`。

### 函数`hypot`三参数重载

<small>趁着还没有被二向箔攻击赶紧用</small>

[P0030R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0030r1.pdf){:target="_blank"}

原来的`hypot`接受两个浮点参数返回以它们为坐标到原点的距离——就是$$\sqrt{x^2+y^2}$$，现在多了一个维度，接受三个参数返回$$\sqrt{x^2+y^2+z^2}$$，当然原来的也还是保留。

### 外部构造、析构函数

<small>委员会：我们把这些函数改个名字又可以拿来卖了</small>

[P0040R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0040r3.html){:target="_blank"}

这么几个新的函数，还有未列出来的带有`_n`后缀的几个，`_n`是什么意思应该都懂的吧……

|`unintialized_value_construct`|数组值初始化|
|`unintialized_default_construct`|数组默认初始化|
|`unintialized_copy`|多了个并行算法|
|`unintialized_move`|从别处移动构造|
|`unintialized_fill`|多了个并行算法|
|`destroy`|析构数组`~T[N]`|
|`destroy_at`|析构对象`~T`|

### 标准容器支持不完全类型构造

<small>所以……多叉树？</small>

[N4510](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html){:target="_blank"}

大概就这个样子`struct X { vector<X> v; };`。还好一开始容器都是空的，可以猜测出大小。

### 库`<chrono>`新功能

[P0092R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0092r1.html){:target="_blank"}
[P0505R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0505r0.html){:target="_blank"}

为`time_point`和`duration`新增加了三个函数，`floor`, `ceil`, `round`，字面意思。

还有为一系列的`operator`函数增加了`constexpr`的声明——既然编译器这么聪明，让它先算好吧。

### `char_traits`中的常量函数

[P0426R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0426r1.html){:target="_blank"}

鉴于定义`constexpr string`（以及最近的`string_view`）常量的时候，在初始化阶段需要计算长度或者其它东西，所以必须要定义一个相应的针对`char_traits`的`constexpr`函数，否则即报编译错误。

所以增加了针对`char_traits`类的一系列`constexpr`函数，包括`length`, `compare`, `assign`, `find`。

### `pair`和`tuple`的构造需要更显式

[N4387](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387.html){:target="_blank"}

不是很懂……大概是说在`pair`和`tuple`里的类，需要显式构造——可是我测试了不显式构造根本编译通过不了……所以我这里也不强行解释了。

### `common_type`的调整

[P0435R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0435r1.pdf){:target="_blank"}
[P0548R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0548r1.pdf){:target="_blank"}

主要是对于`duration`的一系列修改。原来存在`duration`的`ratio`参数不同，结果`common_type`仍然存在`type`的情况，对于这bug进行了一下修复。

## 移除的特性

很多移除的特性都是历史的包袱，以前为了兼容而保留的。

### 三字符组

[N4086](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4086.html){:target="_blank"}

关于这个特性详见[维基百科](https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C.2B.2B){:target="_blank"}。

这个特性在我之前写的[一篇文章](print-hello-world-without-specified-chars/#x02-)提到过。是为了一些键位中没有特殊按键的键盘准备的。它在预处理中的优先级非常高，甚至连字符串中的三元字符组都会被替换。要知道，预处理器不会去替换字符串里的宏。三字符组某些情况下可能会导致严重的程序歧义。

这个特性也是历史的包袱，但是早在C++0x（C++11）就被提出来要移除，但是遭到了IBM的反对，在C++11中不了了之，而在C++17中尽管仍然有IBM的反对，标准委员会表示：你自己写个预处理器把文本中的三字符组转成相应的字符不就好了，于是被移除了。

这个特性在g++中从5.1.0开始默认关闭，编译时有`-trigraph`选项才开启。

### `register`关键字

[P0001R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0001r1.html){:target="_blank"}

同样是兼容久远的C语言的考量而存在，是C语言的32个关键字之一，是个类型修饰关键字。加上这个关键字声明变量会告诉编译器：我这个定义的是临时用、会不停更改的变量（如循环计数变量），你*看情况*把这个变量放到寄存器里优化吧。

然而今天的编译器已经智能到完全可以自行判断是否优化到寄存器里，所以这个关键字已经没人用了。但是虽然被移除，但是保留关键字身份，以后等标准化委员会另外想一个“解释”出来接着用，和`auto`关键字差不多，也是换了个意思接着用。

### 对`bool`的自增运算

<small>返回值永远都是true</small>

[P0002R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0002r1.html){:target="_blank"}

啊？这个有人用吗？移除了对bool类型的前缀和后缀自增。至于自减，抱歉，本来就没有。

实际上在C++98就已经不建议使用，也是标准化之前的东西。

### 异常声明中的`throw`关键字

[P0003R5](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0003r5.html){:target="_blank"}

是指在声明函数的时候后边用`throw(...)`列出的一系列可能异常。这个在C++11开始不建议使用，在C++17中被移除，仅仅保留单独的`throw()`作为C++11新添加的`noexcept(true)`的别名。

### 已经不建议使用的`auto_ptr`、`random_shuffle`以及`<funcitonal>`中旧的类和函数

[N4190](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4190.htm){:target="_blank"}

这些在C++11开始就不建议使用的函数、类在C++17中被删除。

C++11中已经提到，`std::auto_ptr`将由`std::unique_ptr`替代，也就是原本的自动移动指针所有权变成了需要手动`move`来交换指针所有权。

`std::random_shuffle`由`std::shuffle`替代，讲道理哦，这年头，谁还用`srand`。

以下是\<functional\>库里被移除的类和函数，用处为把（一、二元）函数或类的成员指针转化为类、绑定（一、二元）函数的参数，从C++11开始建议使用更一般的`bind`和`mem_fn`替代。

* 类`unary_function`和`binary_function`。这俩是含义为一元、二元函数的空基类，只有几个`typedef`。它们和它们的派生类全部被移除。
* 类`pointer_to_unary_function`和`pointer_to_binary_function`，派生类，比上面两个基类多了构造函数和`operator()`，可以从函数指针构造实例，用`operator()`调用构造时传入的函数。
* 函数`ptr_fun`。调用上面两个类的构造函数，返回上面两个类的实例。
* 类`binder1st`和`binder2nd`。构造时传入二元函数和一个值，绑定构造函数的另一个参数为二元函数的第一个或第二个参数，调用时用`operator()`传入另一个参数，调用传入的函数。
* 函数`bind1st`和`bind2nd`。调用上面两个类的构造函数，返回上面两个类的实例。
* 函数`mem_fun`和`mem_fun_ref`。和下面一堆类的构造函数等价，绑定某些类的成员函数和参数。不带`_ref`的是作为指针用`->`调用成员函数，带有`_ref`的是作为左值引用`.`调用成员函数。
* 类`mem_fun_t`, `mem_fun1_t`, `const_mem_fun_t`, `const_men_fun1_t`, `mem_fun_ref_t`, `mem_fun1_ref_t`, `const_mem_fun_ref_t`, `const_men_fun1_ref_t`。C/C++惯例，带`_t`的都是类型名，是上面两个函数的返回类型。`fun`是无参数的成员函数，`fun1`是带一个参数的成员函数；其实就是第一个参数为`*this`，有没有第二个参数的，就分别是`unary_function`和`binary_function`了，还是重载。

### 已经不建议使用的`iostream`成员别名

[P0004R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0004r1.html){:target="_blank"}

在第一款标准C++98中就已经不再建议，C++17中正式将其移除。因为都是第一套标准统一之后，向无标准时期的各种名称兼容而存在的，所以看起来就是改了个名字。移除的有

* `ios_base::io_state`，C++98中定义为`ios::iostate`
* `ios_base::open_mode`，C++98中定义为`ios_base::openmode`
* `ios_base::seek_dir`，C++98中定义为`ios_base::seekdir`
* `ios_base::streamoff`，C++98中定义为`streamoff`，还记得我说过我懒得打`std::`吗。
* `ios_base::streampos`，C++98中定义为`streampos`
* `basic_streambuf::stossc()`，用途是从读入流里抛弃一个字符，废除。
* 以及所有用到以上变量的函数或重载函数，详见文档。

### 移除`function`中的`allocator`

[P0302R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html){:target="_blank"}

啥……`function`还有`allocator`？`allocate`啥，栈吗？

## 建议不再使用的内容

为兼容性保留，可能会和上面的一样在以后的标准中被移除。

### 静态常量类成员分开声明和定义

[P0386R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf){:target="_blank"}

{% highlight cpp %}
struct S {
  static constexpr int n;
};
constexpr int S::n = 42;
{% endhighlight %}

不再被推荐，建议直接在类中定义，使用如下的C++17新增语法

{% highlight cpp %}
struct S {
  static constexpr int n = 42;
};
{% endhighlight %}

上面提到过。

### 大部分用于兼容C语言的头文件

[P0063R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0063r3.html){:target="_blank"}

* `<ccomplex>`，C的复数类型，由`<complex>`替代
* `<cstdalign>`，C的内存对齐，C++语言自带关键字
* `<cstdbool>`，C的bool类型，C++语言自带关键字
* `<ctgmath>`，C的宏数学库，由C++的函数重载功能配合`<cmath>`实现

还有一个`<ciso646>`未被抛弃，然而这个库实际上并没有任何用，其中的内容也是C++关键字。

### 过时的库组件

[P0174R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r2.html){:target="_blank"}

* `allocator<void>`，由于`allocator<>`的成员函数需要取`sizeof`和取引用，而这对于`void`是非法操作，所以特地定义了`allocator<void>`。然而实际上它连`allocate`和`deallocate`都无法实现，完全是一个空类型，仅仅用来转换。而到了C++11，新封装了`allocator_traits::void_pointer`就不需要担心上述问题了。
* `raw_storage_iterator`
* `get_temporary_buffer`，开始是为了从系统快速申请一块临时使用的buffer，不过貌似没有用。
* `iterator`，继承个P，自己重写去。
* `is_literal`

### 函数`shared_ptr::unique`

[P0521R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0521r0.html){:target="_blank"}

这个函数在多线程环境下是不准确的，因此不再建议使用。

### 类`result_of`

[P0504R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html){:target="_blank"}

由`invoke_result`替代。`result_of<fn(...args)>::type`是以该参数调用相应函数的返回类型。投票结果显示最终使用`invoke_result<fn, ...args>::type`来替代。

## 最后

在油条学长的帮助下学习理解了很多C++11和C++14中我还不理解的部分。还有很多资料来自[cppreference.com](http://en.cppreference.com/w/){:target="_blank"}，之前一直在用的cplusplus反而没有更新C++1z的内容。还有部分来自于stackoverflow，也算是啃下了个大块头。

最后，这周是期中考试周，感觉时间不多了所以先把这篇没有完完全全整理好的先发了出来。总之，有时间接着填坑啦。（说好的FFT呢？（好吧我正在试图写出卷积定理的证明））

期中考要挂科啦！
